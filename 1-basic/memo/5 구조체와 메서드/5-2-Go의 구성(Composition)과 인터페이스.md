## **1. 전통적인 객체지향 개념: 클래스 상속과 다형성**

### **1.1 클래스 상속**

- 객체지향 언어(Java, Kotlin 등)에서 클래스 상속은 기존 클래스(부모 클래스)의 속성과 메서드를 새로운 클래스(자식 클래스)로 재사용 및 확장하는 기능
- 이를 통해 코드 재사용성과 확장성을 높일 수 있지만, 복잡한 상속 구조가 생기면 다음과 같은 문제가 발생할 수 있음
    1. **다중 상속의 모호성**
        - 하나의 클래스가 여러 부모 클래스를 상속받으면, 어떤 부모의 메서드를 사용할지 모호해질 수 있음
    2. **깊은 상속 계층**
        - 상속 계층이 깊어지면 코드 흐름이 복잡해지고 디버깅이 어려움.

### **1.2 다형성**

- 다형성은 **동일한 인터페이스나 부모 클래스를 공유하는 객체가 서로 다른 동작을 할 수 있는 능력**을 의미함.
- 전통적으로 다형성은 **클래스 상속**과 **추상 클래스**를 기반으로 구현됨.
- 복잡한 상속 구조와 다형성 로직은 유지보수와 코드 가독성을 저하시킬 수 있음.

---

## **2. Go의 설계 철학: 단순함과 명확성**

Go는 이러한 복잡한 객체지향 기능(예: 클래스 상속, 추상 클래스, 다중 상속 등)을 **의도적으로 배제**하고, 아래와 같은 기능을 제공함

### **2.1 클래스 상속 대신 구성(Composition)**

- Go는 클래스를 상속하지 않고, **구조체(Struct)**를 사용해 필요한 데이터를 정의하고  **구성(Composition)**을 통해 기능을 재사용합니다.
- 이는 상속 계층 구조 없이도 코드를 유연하게 재사용할 수 있도록 해줍니다.

### **예제: 상속 없이 구성 사용**

```go

package main

import "fmt"

// 공통 기능을 구조체로 정의
type Engine struct {
    HorsePower int
}

func (e Engine) Start() {
    fmt.Println("Engine starting...")
}

// Car는 Engine을 구성으로 포함
type Car struct {
    Engine
    Brand string
}

func main() {
    car := Car{
        Engine: Engine{HorsePower: 150},
        Brand:  "Toyota",
    }

    car.Start() // "Engine starting..."
    fmt.Println("Brand:", car.Brand)
}

```

**해석**:

- `Car`는 `Engine`의 기능을 상속받지 않고, **구성(Composition)**을 통해 재사용.
- 이 방식은 깊은 상속 계층 없이 명확하고 단순하게 동작.

---

### **2.2 다형성 대신 인터페이스**

- Go는 **인터페이스(Interface)**를 통해 다형성을 제공함.
- Go의 인터페이스는 명시적인 구현 선언이 필요하지 않고, 타입이 인터페이스의 메서드를 구현하면 자동으로 해당 인터페이스를 만족함.
- 이를 통해 간단하고 유연한 다형성을 구현할 수 있음.

### **예제: 인터페이스를 통한 다형성**

```go

package main

import "fmt"

// 인터페이스 정의
type Shape interface {
    Area() float64
}

// Circle 타입 정의
type Circle struct {
    Radius float64
}

// Rectangle 타입 정의
type Rectangle struct {
    Width, Height float64
}

// Circle 타입이 Shape 인터페이스를 구현
func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

// Rectangle 타입이 Shape 인터페이스를 구현
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func printArea(s Shape) {
    fmt.Println("Area:", s.Area())
}

func main() {
    c := Circle{Radius: 5}
    r := Rectangle{Width: 4, Height: 6}

    printArea(c) // "Area: 78.5"
    printArea(r) // "Area: 24"
}

```

**해석**:

- `Circle`과 `Rectangle`은 각각 `Shape` 인터페이스를 만족.
- 인터페이스를 통해 동일한 `printArea` 함수가 서로 다른 타입(`Circle`, `Rectangle`)에 대해 다형적으로 동작.

---

### **2.3 철학적 이유**

1. **구성(Composition)으로 단순화**
    - 상속보다 구성을 사용하면 깊은 계층 구조 없이도 재사용성과 확장성을 달성 가능.
    - 설계가 간결하며, 의존성이 줄어듦.
2. **인터페이스로 유연한 다형성**
    - 인터페이스는 객체 간 결합도를 낮추고, 명시적 구현 선언이 필요 없어 개발자의 부담을 줄임.
    - 명확한 의도를 가진 설계가 가능하며, 코드 가독성과 유지보수가 용이.
3. **복잡성 배제**
    - 다중 상속, 추상 클래스 같은 복잡한 구조를 배제하여 코드의 단순성과 명료성을 유지.
    - Go는 "더 적은 것은 더 많은 것(Less is more)"이라는 철학을 따름.

---

## **3. Go의 설계 철학이 제공하는 이점**

1. **단순성**
    - 복잡한 상속 계층 구조와 다형성을 배제해 코드 이해와 유지보수가 쉬움.
2. **명확성**
    - 메서드와 인터페이스를 활용한 설계는 데이터와 동작의 의도를 명확히 표현.
    - 인터페이스는 단순히 "행동 계약"을 정의하여 불필요한 의존성을 줄임.
3. **유연성**
    - 인터페이스 기반 설계는 타입 간 결합도를 줄여 다양한 구현체를 쉽게 교체 가능.
    - Go의 인터페이스는 암시적으로 구현되므로, 기존 코드를 수정하지 않고도 새로운 타입 추가 가능.

---

## **4. Go의 설계와 다른 언어와의 차이**

| **특징** | **Go** | **Java/Kotlin** |
| --- | --- | --- |
| **상속** | 클래스 상속 미지원, 구성(Composition) 사용 | 클래스 상속 및 다중 구현 지원 |
| **다형성** | 인터페이스 기반 다형성 | 상속 및 인터페이스 기반 다형성 |
| **결합도** | 낮은 결합도, 명시적 구현 불필요 | 클래스 계층 구조로 인해 높은 결합도 가능 |
| **복잡성** | 단순하고 명확한 설계 | 복잡한 계층 구조나 다형성으로 인해 설계가 복잡해질 수 있음 |

---

## **5. 결론**

Go는 객체지향 언어가 아니지만, **구성(Composition)**과 **인터페이스**를 통해 객체지향의 핵심 요소(재사용성, 다형성 등)를 단순하고 명확하게 구현할 수 있습니다.

- 상속과 다형성을 배제한 설계는 Go의 철학인 **간결함, 성능, 효율성**을 잘 반영합니다.
- Go의 접근 방식은 대규모 시스템에서 코드 가독성과 유지보수를 용이하게 만들며, 개발자에게 더 많은 제어권을 제공합니다.