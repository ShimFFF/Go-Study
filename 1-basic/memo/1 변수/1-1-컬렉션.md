## **1. 배열 (Array)**

### **1.1 배열이란?**

- 배열은 고정된 크기의 **동일한 데이터 타입** 요소를 저장하는 컬렉션
- 배열의 크기는 선언 시 고정되며, 이후 변경할 수 없음

### **1.2 배열의 사용법**

### **배열 선언**

1. **명시적 크기 선언** 
    
    ```go
    
    var arr [3]int // 정수형 요소 3개를 저장하는 배열
    
    ```
    
2. **초기화와 선언** 
    
    ```go
    
    arr := [3]int{1, 2, 3} // 요소 초기화
    
    ```
    
3. **크기 생략 (초기화 값에 따라 크기 결정)** 
    
    ```go
    
    arr := [...]int{1, 2, 3, 4} // 자동으로 크기 결정
    
    ```
    

### **배열 접근 및 수정**

- 배열 요소는 **인덱스**를 사용해 접근. 인덱스는 0부터 시작함
- 요소 값 변경
    
    ```go
    
    arr[0] = 42
    
    ```
    

### **예제: 배열 사용**

```go

package main

import "fmt"

func main() {
    var arr [3]string
    arr[0] = "Hello"
    arr[1] = "World"
    arr[2] = "Go"

    for i, v := range arr {
        fmt.Printf("Index %d: %s\n", i, v)
    }
}

```

### **출력**

```yaml

Index 0: Hello
Index 1: World
Index 2: Go

```

---

### **1.3 배열의 특징**

1. 고정된 크기: 크기가 정해지면 변경 불가.
2. 값 타입: 배열은 복사되어 전달되므로 원본은 변경되지 않음.
3. 제한적 사용: 크기가 고정되어 유연성이 부족.

---

## **2. 슬라이스 (Slice)**

### **2.1 슬라이스란?**

- 슬라이스는 배열을 기반으로 하며, 배열의 **가변 길이 부분집합**
- **동적 크기**를 지원하여 배열보다 유연함.
- 내부적으로는 배열을 참조하며, 슬라이스의 크기를 자유롭게 변경할 수 있음.

### **2.2 슬라이스의 사용법**

### **슬라이스 선언**

1. **기존 배열로부터 슬라이스 생성**
    
    ```go
    
    arr := [5]int{1, 2, 3, 4, 5}
    slice := arr[1:4] // 2, 3, 4 (1~3 인덱스)
    
    ```
    
2. **`make` 함수로 생성**
    
    ```go
    
    slice := make([]int, 3, 5) // 길이 3, 용량 5
    
    ```
    
3. **리터럴로 생성**
    
    ```go
    
    slice := []string{"Go", "is", "awesome"}
    
    ```
    

### **슬라이스 수정 및 접근**

- 슬라이스는 배열과 동일하게 인덱스를 통해 요소에 접근하거나 수정함.
- 동적 크기 변경
    
    ```go
    
    slice = append(slice, 6, 7) // 요소 추가
    
    ```
    

### **예제: 슬라이스 사용**

```go

package main

import "fmt"

func main() {
    nums := []int{1, 2, 3}
    nums = append(nums, 4, 5)

    for i, v := range nums {
        fmt.Printf("Index %d: %d\n", i, v)
    }
}

```

### **출력**

```yaml

Index 0: 1
Index 1: 2
Index 2: 3
Index 3: 4
Index 4: 5

```

---

### **2.3 슬라이스의 특징**

1. **동적 크기**: 필요에 따라 크기를 조정 가능.
2. **포인터 참조**: 슬라이스는 배열을 참조하므로 값 변경 시 원본에 영향을 줄 수 있음.
3. **효율적 사용**: 유연성과 성능을 모두 지원.

---

## **3. 맵 (Map)**

### **3.1 맵이란?**

- 맵은 키-값 쌍(Key-Value Pair)으로 데이터를 저장하는 컬렉션임.
- 모든 키는 **고유**하며, 값을 기반으로 데이터를 검색함.

---

### **3.2 맵의 사용법**

### **맵 선언**

1. **`make` 함수로 생성**
    
    ```go
    
    m := make(map[string]int) // 키는 문자열, 값은 정수
    
    ```
    
2. **리터럴로 초기화**
    
    ```go
    
    m := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }
    
    ```
    

### **맵에 데이터 추가/수정**

- 값 추가 또는 수정
    
    ```go
    
    m["Alice"] = 35 // Alice의 나이를 35로 수정
    m["Charlie"] = 20 // 새 데이터 추가
    
    ```
    

### **맵 데이터 삭제**

- 데이터 삭제
    
    ```go
    
    delete(m, "Bob") // Bob 데이터 삭제
    
    ```
    

### **맵 데이터 조회**

- 값을 조회하고 존재 여부를 확인
    
    ```go
    
    value, exists := m["Alice"]
    if exists {
        fmt.Println("Alice's age is", value)
    } else {
        fmt.Println("Alice not found")
    }
    
    ```
    

### **예제: 맵 사용**

```go

package main

import "fmt"

func main() {
    m := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }

    m["Charlie"] = 20 // 새 데이터 추가
    delete(m, "Bob")  // 데이터 삭제

    for key, value := range m {
        fmt.Printf("%s: %d\n", key, value)
    }
}

```

### **출력**

```makefile
Alice: 30
Charlie: 20

```

---

### **3.3 맵의 특징**

1. **키-값 쌍 저장**: 데이터를 고유한 키로 관리.
2. **동적 크기**: 필요에 따라 크기 조정 가능.
3. **빠른 검색**: 해시 기반 구조로 효율적 조회.

---

## **4. 주요 차이점**

| **특징** | **배열(Array)** | **슬라이스(Slice)** | **맵(Map)** |
| --- | --- | --- | --- |
| **크기** | 고정 | 동적 | 동적 |
| **데이터 참조** | 값 타입 | 참조 타입 | 참조 타입 |
| **데이터 구조** | 인덱스 기반 | 인덱스 기반 | 키-값 기반 |
| **사용 목적** | 고정 크기 데이터 관리 | 동적 크기 데이터 관리 | 키를 기반으로 데이터 관리 |
| **데이터 검색** | 인덱스 | 인덱스 | 키 |

---

- **배열(Array)**
    - 크기가 고정된 데이터를 관리할 때 적합.
- **슬라이스(Slice)**
    - 크기가 동적이고 유연한 데이터 처리를 지원하며 배열을 대체.
- **맵(Map)**
    - 키-값 쌍을 저장하고 검색할 때 가장 유용.